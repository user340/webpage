<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<title>e-yuuki.org</title>
</head>
<body>
<article class="tiny">
<h1>Unixとテキストファイル</h1>
<figure style="text-align:right">
<blockquote><p>ほとんどのUNIX環境には、テキストの送信、修正、フィルタ処理のためのユーティリティが何十と存在し、UNIXユーザーはそれをさまざまに組み合わせて、日常の業務を行っている。</p></blockquote>
<footer>Mike Gancarz『UNIXという考え方』（p.59）</footer>
</figure>
<hr>
<p>UNIX哲学にもあるように、Unix系OSを使う上でテキストファイル（text file）を扱うことは避けては通れません。むしろテキストファイルあるいはそれに収められたデータを高速かつ効率的に処理したいからこそUnix系OSを使う意義があるのです。本稿ではテキストファイルの利点について簡単に述べたあとに、Unix系OS上でテキストファイルを扱うコマンドをいくつか紹介します。</p>

<ol>
<li><a href="#philosophy">UNIX哲学が主張するテキストファイルの優位性</a></li>
<li><a href="#today">テキストファイルの現在</a></li>
<li><a href="#tools">テキストファイルを処理する便利なツール</a>
<ol>
<li><a href="#cut">cut&mdash;&mdash;各行を列単位で切り取る</a></li>
<li><a href="#sort">sort&mdash;&mdash;行をソートする</a></li>
<li><a href="#grep">grep&dash;&dash;パターンに一致した文字列を抽出する</a></li>
<li><a href="#stream">テキストストリームとパイプ／リダイレクト</a></li>
</ol></li>
</ol>

<h2 id="philosophy">UNIX哲学が主張するテキストファイルの優位性</h2>
<p>「UNIX哲学」の「哲学」とは「設計思想」や「実践」「考え方」のような意味で使われています。どこかの委員会や学会で定義されているものではありません。またUNIX哲学にしたがって開発した結果UNIXが生まれたのでもありません。UNIXが生まれてプログラマに長年利用された結果、すぐれた設計や実践が見つかりUNIX哲学としてまとめることができた……というある意味結果論的なものです。</p>

<p>UNIX哲学の解説書として一般的なのはMike Gancarzによる『The Unix Philosophy』です（芳尾 桂 監訳, 『UNIXという考え方』, オーム社 開発局, 2001）。この本ではUNIX哲学を9の定理と10の小定理に分け、それらの定理についてそれぞれ解説を述べています。日本語版にして約150ページ弱とやや薄めの本です。</p>

<p>Gancarzはテキストファイル（『UNIXという考え方』では「ASCIIフラットファイル」と呼ばれている）について「データが生きて価値を持ち続けるためには、必要なときには移動しなければならない」（p.58）したがって「動かせないデータは、死んだデータ」（p.58）であるという前提から、「ASCIIテキストは、最良の形式ではないまでも、間違いなく最も一般的な形式」（p.58）であり、データは移植性に長けいつでも動かせるテキストファイルとして保存すべきだという定理を導いています。くわえてテキストファイルの中身はなにかしらの変換をせずともテキストエディタで確認できること、UNIXにはテキストファイルを処理するためのコマンドが豊富に用意されておりテキストファイル中のデータを簡単に処理できることを利点として挙げています。</p>

<h2 id="today">テキストファイルの現在</h2>
<p>今日ではテキストファイルそのものは未だに健在です。一方でRHEL系のGNU/Linux OSで使われている<code>journald</code>はログをバイナリ形式で保存します。今後、ユーザがテキストエディタで直接設定ファイルやログファイルを閲覧・編集する機会が減るのであれば、データ自体の形式はよりコンパクトな方へ移行されるのではないかと予想しています。また同じテキストファイルにしても、JSONやYAMLといった行指向ではない形式でデータを表現する機会も多くなりました。これらのようなデータ形式のパーサは、いまどきのプログラミング言語だと標準ライブラリやパッケージとして提供されており使い方も簡単です。しかし伝統的な行指向のテキスト処理コマンドである<code>sed</code>や<code>awk</code>、<code>grep</code>などではデータを解析するだけでも一苦労です。</p>

<figure>
<pre><code><b>{
    "example": {
        "a": 0,
        "b": 1,
        "c": 2,
        "d": 3
    }
}</b></code></pre>
<figcaption><b>図1: </b>テキストファイルだがJSON形式によるデータ表現</figcaption>
</figure>

<figure>
<pre><code><b>#!/usr/bin/env python
import json

with open('example.json', mode='r', encoding='utf-8') as f:
    data = json.load(f)

print(data['example']['a'])  # 0
print(data['example']['b'])  # 1
print(data['example']['c'])  # 2
print(data['example']['d'])  # 3</b></code></pre>
<figcaption><b>図2: </b>Python 3.8によるJSONの解析</figcaption>
</figure>

<figure>
<pre><code><b class="user">grep "3" example.json</b>
<b>        "d": 3</b></code></pre>
<figcaption><b>図3: </b><code>grep</code>は行指向でテキストを処理するため、これだけではどのキーに対応した辞書のメンバか判別できない</figcaption>
</figure>

<p>POSIXで定義されたコマンドではありませんが、喜ばしいことに<code>jq</code>や<code>yq</code>のようなコマンドライン上でも高級なデータ形式を解析できるコマンドが存在します。おそらく多くの環境では別途当該パッケージのインストールが必要でしょう。</p>

<p>Gancarzが言うようにテキストファイルそのものは残り続けていますが、それをどう解析するかが悩みの種になっています。もしPOSIXで定義されたUnixコマンドのみでテキストファイル内のデータを素早く処理したい場合、データ形式は行指向でなければなりません。</p>

<h2 id="tools">テキストファイルを処理する便利なツール</h2>
<p>テキストファイルの利点とテキストファイルを処理するにあたっての課題がわかったところで、行指向のデータを処理するという前提のもとに、テキストファイルを処理するのに便利なツールを紹介します。本節では図4に示すテキストファイルを処理するものとします。</p>

<figure>
<pre><code><b>john,23,student
smith,40,doctor
luke,26,student
marcy,34,writer
bob,50,programmer
dennis,38,consultant</b></code></pre>
<figcaption><b>図4: </b>例として示すテキストファイル<b>example.txt</b>はコンマ区切りで「名前」「年齢」「職業」をあらわす。</figcaption>
</figure>

<h3 id="cut">cut&dash;&mdash;各行を列単位で切り取る</h3>
<p><code>cut</code>は与えられたテキストの各行を列単位で切り取ることができます。たとえばexample.txtでは一列目が名前を示しています。テキストファイルから名前だけを切り取りたいときは次のように<code>cut</code>を実行します。</p>

<pre><code><b class="user">cut -d "," -f 1 example.txt</b>
john
smith
luke
marcy
bob
dennis</code></pre>

<p>ここでオプション<code>-d</code>には区切り文字を渡し、どのような文字が列の区切りとして機能しているかを<code>cut</code>に教えています。</p>

<h3 id="sort">sort&mdash;&mdash;行をソートする</h3>
<p><code>sort</code>は与えられたテキストを昇順に並べます。</p>

<pre><code><b class="sort">sort example.txt</b>
bob,50,programmer
dennis,38,consultant
john,23,student
luke,26,student
marcy,34,writer
smith,40,doctor</code></pre>

<p><code>sort</code>単体で使うことはあまりありません。おもに<code>-u</code>オプションと組み合わせて行の重複を取り除くために使われます。<code>sort | uniq</code>でも行の重複を取り除けられます。</p>

<h3 id="grep">grep&mdash;&mdash;パターンに一致した文字列を抽出する</h3>
<p><code>grep</code>は与えられたテキストの各行に対して、パターンに一致している文字列を持つ行を抽出します。パターンには正規表現を利用できます。たとえば文字列"student"を含む行を抽出するときには以下のように実行します。</p>

<pre><code><b class="user">grep "student" example.txt</b>
john,23,student
luke,26,student</code></pre>

<p>次に、名前が文字列"den"から始まる行を抽出してみましょう。出力は"dennis"さんの行だけが期待しているものとなります。先ほどの例にしたがうと<code><b>grep "den" example.txt</b></code>と実行したくなりますが、これでは"stu<b>den</b>t"を持つ行にも一致してしまい、期待どおりの出力になりません。</p>

<pre><code><b class="user">grep "den"</b>
john,23,student
luke,26,student
dennis,38,consultant</code></pre> 

<p>幸いにもこのデータでは名前は先頭の列にあると分かっています。そこで<code>grep</code>を「先頭の文字列が"den"で始まる行を抽出」するよう実行します。このようなとき、正規表現を組み合わせることでパターンを補強できます。</p>

<pre><code><b class="user">grep "^den" example.txt</b>
dennis,38,consultant</code></pre>

<p>正規表現については、それだけで本を一冊書けるほどには奥深く難しいものなのでここでは解説をしません。</p>

<h2 id="stream">テキストストリームとパイプ／リダイレクト</h2>
<hr>
<footer><div style="text-align:center;padding-top:2em;padding-bottom:2em;"><a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/"><img src="https://i.creativecommons.org/p/zero/1.0/88x31.png" alt="CC0" /></a></div><p>To the extent possible under law, <a href="mailto:uki@e-yuuki.org">Yuuki Enomoto</a> has waived all copyright and related or neighboring rights to e-yuuki.org. This work is published from: Japan.</p></footer></article></body></html>
